import { Map } from '../../../util';
import T from '../../T';
import VertexProperty from '../../VertexProperty';
import GraphSONTokens from '../../io/graphson/GraphSONTokens';
import StarGraph from './StarGraph';


export default class StarGraphGraphSONDeserializer {
  /**
   * A helper function for reading vertex edges from a
   * serialized {@link org.apache.tinkerpop.gremlin.structure.util.star.StarGraph} (i.e. a {@link java.util.Map}) generated by
   * {@link org.apache.tinkerpop.gremlin.structure.util.star.StarGraphGraphSONSerializerV1d0}.
   */
  static readStarGraphEdges(graph, edgeDatas, vertexOut) {

    while (edgeDatas.hasNext()) {
      const edgeData = edgeDatas.getValue();
      for (let j = 0; j < edgeData.length; j++) {
        const inner = edgeData[j];
        const vertexIn = graph instanceof Map
          ? graph.getValue(inner[GraphSONTokens.IN])
          : graph._vertices.getValue(inner[GraphSONTokens.IN]);
        let starEdge = vertexOut.addEdge(edgeDatas.getKey(), vertexIn, T.id, inner[GraphSONTokens.ID]);
        if (GraphSONTokens.PROPERTIES in inner) {
          const edgePropertyData = new Map(inner[GraphSONTokens.PROPERTIES]).keySet();
          while (edgePropertyData.hasNext()) {
            const epd = new Map(edgePropertyData.getValue()).keySet();
            starEdge.property(epd.getKey(), epd.getValue());
            edgePropertyData.next();
          }
        }
      }
      edgeDatas.next();
    }
  }

  /**
   * A helper function for reading a serialized {@link org.apache.tinkerpop.gremlin.structure.util.star.StarGraph}
   * from a {@link java.util.Map} generated by
   * {@link org.apache.tinkerpop.gremlin.structure.util.star.StarGraphGraphSONSerializerV1d0}.
   */
  static readStarGraphVertex(vertexData, starGraph) {
    const vertex = starGraph.addVertex(T.id, vertexData[GraphSONTokens.ID], T.label, vertexData[GraphSONTokens.LABEL]);

    if (GraphSONTokens.PROPERTIES in vertexData) {
      const properties = new Map(vertexData[GraphSONTokens.PROPERTIES]).keySet();
      while (properties.hasNext()) {
        const property = properties.getValue();
        for (let j = 0; j < property.length; j++) {
          const p = property[j];
          const vp = vertex
            .property(VertexProperty.Cardinality.list, properties.getKey(), p[GraphSONTokens.VALUE], T.id, p[GraphSONTokens.ID]);
          if (GraphSONTokens.PROPERTIES in p) {
            const edgePropertyData = new Map(p[GraphSONTokens.PROPERTIES]).keySet();
            while (edgePropertyData.hasNext()) {
              const epd = new Map(edgePropertyData.getValue()).keySet();
              vp.property(epd.getKey(), epd.getValue());
              edgePropertyData.next();
            }
          }
        }
        properties.next();
      }
    }
    return vertex;
  }

}