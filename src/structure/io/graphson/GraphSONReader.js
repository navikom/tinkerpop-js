import { Map, Logger } from '../../../util';
import GraphSONMapper from './GraphSONMapper';
import GraphSONTokens from './GraphSONTokens';
import GraphSONVersion from './GraphSONVersion';
import StarGraphGraphSONDeserializer from '../../util/star/StarGraphGraphSONDeserializer';

/**
 * A @{link GraphReader} that constructs a graph from a JSON-based representation of a graph and its elements.
 * This implementation only supports JSON data types and is therefore lossy with respect to data types (e.g. a
 * float will become a double, element IDs may not be retrieved in the format they were serialized, etc.).
 * {@link Edge} and {@link Vertex} objects are serialized to {@code Map} instances.  If an
 * {@link org.apache.tinkerpop.gremlin.structure.Element} is used as a key, it is coerced to its identifier.  Other complex
 * objects are converted via {@link Object#toString()} unless there is a mapper serializer supplied.
 *
 */
export default class GraphSONReader {
  constructor(builder) {
    this.mapper = builder._mapper;
    this.version = builder._mapper.getVersion();
  }

  /**
   * Read data into a {@link Graph} from output generated by any of the {@link GraphSONWriter} {@code writeVertex} or
   * {@code writeVertices} methods or by {@link GryoWriter#writeGraph(OutputStream, Graph)}.
   *
   * @param json a stream containing an entire graph of vertices and edges as defined by the accompanying
   *                    {@link GraphSONWriter#writeGraph(OutputStream, Graph)}.
   * @param graphToWriteTo the graph to write to when reading from the stream.
   */
  readGraph(json, graphToWriteTo) {
    // dual pass - create all vertices and store to cache the ids.  then create edges.  as long as we don't
    // have vertex labels in the output we can't do this single pass
    const cache = new Map();
    const logger = Logger.init();
    logger.start();
    const rows = this.readVertexStrings(json);
    const logger2 = Logger.init();
    logger2.start();
    rows.map((entry) => this.readVertex(entry,
      null, null, null, graphToWriteTo)).forEach((vertex) => {
      cache.put(vertex.id(), vertex);
    });
    logger2.info('GraphSONReader::vertices');
    const logger3 = Logger.init();
    logger3.start();
    rows.filter((entry) => GraphSONTokens.OUT_E in entry).map((entry) => {
      const out = new Map(entry[GraphSONTokens.OUT_E]).keySet();
      const vertex = cache.getValue(entry[GraphSONTokens.ID]);
      StarGraphGraphSONDeserializer.readStarGraphEdges(cache, out, vertex);
    });
    logger3.info('GraphSONReader::edges');
    logger.info('GraphSONReader::readGraph');
  }

  /**
   * Read {@link Vertex} objects from output generated by any of the {@link GraphSONWriter} {@code writeVertex} or
   * {@code writeVertices} methods or by {@link GraphSONWriter#writeGraph(OutputStream, Graph)}.
   *
   * @param inputStream a stream containing at least one {@link Vertex} as defined by the accompanying
   *                    {@link GraphWriter#writeVertices(OutputStream, Iterator, Direction)} or
   *                    {@link GraphWriter#writeVertices(OutputStream, Iterator)} methods.
   * @param vertexAttachMethod a function that creates re-attaches a {@link Vertex} to a {@link Host} object.
   * @param edgeAttachMethod a function that creates re-attaches a {@link Edge} to a {@link Host} object.
   * @param attachEdgesOfThisDirection only edges of this direction are passed to the {@code edgeMaker}.
   */
  //readVertices(inputStream, vertexAttachMethod, edgeAttachMethod, attachEdgesOfThisDirection) {
  //	return this.readVertexStrings(inputStream)
  //		.map(FunctionUtils.wrapFunction((line) =>
  //			this.readVertex(line.getBytes(), vertexAttachMethod, edgeAttachMethod, attachEdgesOfThisDirection))).iterator();
  //}

  /**
   * Read a {@link Vertex} from output generated by any of the {@link GraphSONWriter} {@code writeVertex} or
   * {@code writeVertices} methods or by {@link GraphSONWriter#writeGraph(OutputStream, Graph)}.
   *
   * @param node a stream containing at least one {@link Vertex} as defined by the accompanying
   *                    {@link GraphWriter#writeVertices(OutputStream, Iterator, Direction)} method.
   * @param vertexAttachMethod a function that creates re-attaches a {@link Vertex} to a {@link Host} object.
   * @param edgeAttachMethod a function that creates re-attaches a {@link Edge} to a {@link Host} object.
   * @param attachEdgesOfThisDirection only edges of this direction are passed to the {@code edgeMaker}.
   */
  readVertex(node, vertexAttachMethod, edgeAttachMethod, attachEdgesOfThisDirection, graphToWriteTo) {

    if (edgeAttachMethod !== undefined) {
      const vertexData = node;
      const vertex = StarGraphGraphSONDeserializer.readStarGraphVertex(vertexData, graphToWriteTo);

      return vertex;
    } else {
      return this.readVertex(node, vertexAttachMethod, null, null, graphToWriteTo);
    }

  }

  readVertexStrings(nodes) {
    return nodes;
  }

  static build() {
    return new Builder();
  }

}

class Builder {
  constructor() {
    this._mapper = GraphSONMapper.build().create();
  }

  /**
   * Override all of the {@link GraphSONMapper} builder
   * options with this mapper.  If this value is set to something other than null then that value will be
   * used to construct the writer.
   */
  mapper(mapper) {
    this._mapper = mapper;
    return this;
  }

  create() {
    return new GraphSONReader(this);
  }
}