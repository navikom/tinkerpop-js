import { Map } from '../../../util';
import GraphSONMapper from './GraphSONMapper';
import GraphSONTokens from './GraphSONTokens';
import GraphSONVersion from './GraphSONVersion';
import StarGraphGraphSONDeserializer from '../../util/star/StarGraphGraphSONDeserializer';

/**
 * GraphSONUpdater
 * for update existing graph
 *
 */
export default class GraphSONUpdater {
	constructor(builder) {
		this.mapper = builder._mapper;
		this.version = builder._mapper.getVersion();
	}

	/**
	 * Update data into a {@link Graph} from output generated by any of the {@link GraphSONUpdater} {@code updateGraph} or
	 * {@code writeVertices} methods or by {@link GryoWriter#writeGraph(OutputStream, Graph)}.
	 *
	 * @param json a stream containing an entire graph of vertices and edges as defined by the accompanying
	 *                    {@link GraphSONWriter#writeGraph(OutputStream, Graph)}.
	 * @param graphToWriteTo the graph to write to when reading from the stream.
	 */
	updateGraph(json, graphToWriteTo) {

		const rows = this.readVertexStrings(json);
		rows.map((entry) => this.readVertex(entry, graphToWriteTo));

		rows.filter((entry) => GraphSONTokens.OUT_E in entry).map((entry) => {
			const out = new Map(entry[GraphSONTokens.OUT_E]).keySet();
			const vertex = graphToWriteTo._vertices.getValue(entry[GraphSONTokens.ID]);
			StarGraphGraphSONDeserializer.readStarGraphEdges(graphToWriteTo, out, vertex);
		})

	}

	/**
	 *
	 * @param node
	 * @param graphToWriteTo
	 * @returns {*}
	 */
	readVertex(node, graphToWriteTo) {
		let vertex;
		if (graphToWriteTo._vertices.containsKey(node[GraphSONTokens.ID])) {
			vertex = graphToWriteTo._vertices.getValue(node[GraphSONTokens.ID]);
			vertex.remove();
		}
		vertex = StarGraphGraphSONDeserializer.readStarGraphVertex(node, graphToWriteTo);

		return vertex;

	}

	readVertexStrings(nodes) {
		return nodes;
	}

	static build() {
		return new Builder();
	}

}

class Builder {
	constructor() {
		this._mapper = GraphSONMapper.build().create();
	}

	/**
	 * Override all of the {@link GraphSONMapper} builder
	 * options with this mapper.  If this value is set to something other than null then that value will be
	 * used to construct the writer.
	 */
	mapper(mapper) {
		this._mapper = mapper;
		return this;
	}

	create() {
		return new GraphSONUpdater(this);
	}
}
